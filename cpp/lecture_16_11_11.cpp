Поехали!
void f(const person_t *p); //C
void f(const person & p);// C++

Но не ради этого мы здесь собрались

Перегурзка операторов! (какого всё зелёное?)

1. f(int); f(double); f(int, double); //Cи бы офигел, а плюсам норм, ибо линкер умнее, он включает инфу о типах
это была перегрузка, теперь операторы:
+, -, *, [], ==, (type)
перегрузка... операторы... Хэммм.. Перегурзка операторов! 

Int + Int ну норм идея

bigInt + bigInt Что это? Но тоже норм, если постараться.

Сейчас научимся делать это, разобьём на две части (разобью горизонтально)

*, +...
&&,..
&,..
==,..
++,..
+=,..
--------
(type), =, конструктор копий,
[],
*p,
p->

goto next

my_array я начну вот с этого, но, послушайте, давайте без этого, чтобы был один пример, с точки зрения реализации особых отличий нет
С точки зрения хранения bigInt мало отличается от my_array,

Какие способы хранения?
Когда мы один разряд храним в одной ячейке. 
6|5|5|3|5|0|0|0|0
Это неэффективно, но кого это волнуют? Мы же ради примера, а ради него людей даже паскалю учат

Вообщем есть у меня 
BigInt
	int *array;
	size_t size;

1. 	BigInt a(30);
	BigInt b(a);

Хотим, чтоб Б была копией А.
Когда бывает такое?
void f(BigInt obj){

}
Тут то же самое, нужно создать генирование копии.
К чему может привести простое перекопирование всех полей, которое идёт по умолчанию?
Пример:
g(){
	BigInt a(30);
	BigInt b(a);
}
-------
|array  | ----->| | | | | | | |
|size 30|        ^
				 |
|array  |---------
|size 30|
Почему плохо? Да программа упадёт на деструкторе. Когда дойдём до скобки - вызовутся деструкторы у всех классов, вызывется деструктор А и всё будет ок,
а вот у Б уже нет значений, а деструктор хочет удалять. Беда.

class point{
	int x;
	int y;
}
А тут проблем не будет, однако. Ибо проблема возникает, когда мы работает с ресссурсами, типо выделения памяти, файлами и бла бла,
 когда мы указываем на одно и тоже место в памяти, которое не стоит удалять 2 раза, например.

class BigInt{
public:
	//BigInt(BigInt obj)//Я начал творить какой-то ад. Для того, чтобы создать копию - надо создать копию. Ссылку в студию!
	BigInt(BigInt& obj){//b BigInt b(a); ==> b.конструктор_копий(a) // забавная запись // забавные комментарии комментариев
		this->size = obj.size;//Воу воу, мы не трогали раньше this
		this->array = new int[this->size];//Что ещё скопировать? ЧТО СКОПИРОВАТЬ?
		for (int i=0; i<this->size; i++)//В учебных целях страдаем с this, чтобы понять, что откуда берётся
			this->array[i]=obj.array[i];
	}
}

|array  | ----->| | | | | | | |
|size 30|        
				 
|array  | ----->| | | | | | | |
|size 30|
good enough!

он чот написал, но мне лень переписывать, я был занят рисунками в sublime
Если нет конструторов - компилятор скомпилит такой конструктор BigInt(){}//Не самый полезный конструктор. С деструктором аналогично
Есть вопросы? Вопрос вообще-то есть у меня.
Слушайте, у меня эти поля приватные, а я тут беру и получаю доступ? Как? Да они родственники, они же из одного класса, стираем границы приличия

Окей

Давайте-ка обсудим щас близкая тема это с приведением типов //лол

1.BigInt a = 3; Ну вот приведение. Обсдуили.
Ладно, го подробнее
BigInt a = (BigInt)3;//теперь более явно.
2.BigInt a(30);
int b = a;
Вот тут вообще весело. Оставим это на потом.

Начнём с первого случая. Что это и с чем это есть? Чтобы оно сработало - у нашего класса должен быть конструктор вот такой:
Воттакенный:
BigInt(int)

BigInt a = (BigInt)3;
	^		 v
 a(tmp)<----tmp
Современные компиляторы умнее.
Было бы всё проще - было бы всё просто.
Но мы пошли другим путём, смысл BigInt(size_t) в размере, а не в значении, поэтому приведение непонятное
И он вместо того, чтобы заполнить массив - создаст массив длины три.

explicit BigInt(size_t) // значит - Низя делать привеление типа вот так вот
(v) BigInt b(3);
(x) BigInt b = 3;
Писать иксплисит или нет? Вот в чём вопрос. Ну вот и задавайте его себе, ибо чёрт знает, как вы всё это у себя реализуюте.
В нашей реализации может получиться странно использовать такие приведения.

Скоро перерыв, только вот задачку надо делать

Ситауция вторая, разбираем "присвоить"

BigInt a(30);
a.set (0,5);
a.set (1,6);
BigInt b(30);
b.set(0,7);
b.set(5,3);
b = a;
В чём разница? Я просто хочу копию!
Да вот там размер уже какой-то есть в b;
Б сущетсвует, там есть память, числа. Я хочу записать туда А, в чём проблема?
В new! //Тут он рисует таблички чисел, но это сложно их в саблайм переносить, пишите в тетрадки, мне лень, и так понятно
//Что будет делать компилятор.
//Память протекла, да ещё и все прошлые проблемы.
Нужно перегрузить присваивание. 
// По умолчанию опертор присваивания не сработет, тогда, когда вам яыно нужен деструктор, значит нужны и копии и присваивания.
пррв.


прдлжм
b.operator=(a);
по умочанию также, как и копирование.
Напишем наш оператор.
operator=(const BigInt &obj){
	delete []this->array;
	this->size = obj.size;
	this->array = new int[this->size];
	for (size_t i = 0; i<this->size; i++)
		this->array[i]=obj.array[i];
}
//Идиома swap попозже обсудим, это чтоб скопировать через функцию.
У этого кода есть 2 проблемы. Одна - копирование себя же.
BigInt a(30);
	a=a;
В нашем случае произойдёт беда
Вторая - 
int a =3; int b =5; int c =6;
a = b = c;
a.operator=(b.operator=(c));
Должно быть возращаемое значение.

BigInt& operator=(const BigInt &obj){
	if (&obj!=this){//wtf &obj - это адрес обжа, ибо мы obj пользовались, как обычным объектом.ёё
		delete []this->array;
		this->size = obj.size;
		this->array = new int[this->size];
		for (size_t i = 0; i<this->size; i++)
			this->array[i]=obj.array[i];
	}
	return *this; //Зыс - это указатель, его надо раизменовать.
}

BigInt* getOnes(){
	BigInt a(100);
	for(int i=0; i<100; i++)
		a.set(i,1);
	return &a;
}//деструкторы убивают всю память

main() {
	BigInt *p=getOnes();//Память метрва
	p->get(3);
}
//C++
BigInt getOnes(){
	BigInt a(100);
	for(int i=0; i<100; i++)
		a.set(i,1);
	return a;
}

main() {
	BigInt p=getOnes();//Конструктор копирования в RV, потом деструктор а, потом конструктор копир rb => p
	p.get(3);
}

Наше стэк
|    | p  |       |
| RA | RV | a | i |

третья Ситауция

BigInt a(30);
a = getOnes();
//Тут operator=

..........
BigInt a(30);
BigInt b(40);
bigInt c(50);
c=b=a; 
Почему всё нормально работает? Хотя там ссылки.

BigInt{
	BigInt& get(){
		return *this;
	}
}
BigInt a(30);
BigInt &p = a.get();
p,set(1,5);
Почему ок? переменная создаётся тут, а не в той функции. Всё оки, ибо память лежит тут, а не деструктится

сл-но
c=b=a; берёт память с того же места в стеке, где и равно вызывается
